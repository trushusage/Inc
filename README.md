eNrNWv9TIjkW_1ey-INOLbqi4zhSNTOFgrPcjOgC1qxXVlGhO2KO7jTXSevg1v7v93lJumkQUHedu1t3UCB57-W9z_ua_qMSJKGo1Cu1bdb71j7tD07Ou61Bv9s4PW2fDHr9Rrffal6ra6XFvzOhAtGUfJTymD5i-G9jzTb2gfXu5Y1hJ0kqmJbaiFiyWGj-L2ZSfiNHUgk25DriIf0dcr-IDTNm5ITJCF_LKJSpjOmNEYEYG5nu5Nx734j04ExozUdi0EmMvJEBNzJRg98ykQm2_fEja6sgiaUaDaw086u-EkMl0vra4xOv51Cx7DR9H5BcUhmR8sAuMXwYiTqTUGRqntA1_extM38s9rXd67c6T5ihzCulRdo4nvjuJImyWGlwD6tzC-m9mU5ElWnDTabxO8nSAO8nfBolHF8HqeBGDEK8VFk2CfM3M75zavEy60Hf897yzD3vUHzfjCTLlISIxQlluFVobTPkyhob_2Budtb_cNbuVtnZ7x-OMw3EaM0ak0nkdc9-FTwU6aZUObV2KBTZBuaYciXZLf6w1B30JJMBFnsJfmZXPA1lHEgC3TiJQHECuPF0ysZiyqYiJZD61UGiNJCroEOWRDpTLBSh3IEMscci4DyScSQjABpL4myapJAgxkKmsijCZxyQlvh4503VwcEr1wJ20OGxgOPkkO7PWeey1e--WQD_BQ_07u57__tocNY_qu3S61v7erDrPEFbbC63VskLOuI-5z3D1nnEtWS9JM0inlbZqRDhkAfjzQiavROA10MW42_p12-wKwG996Eo7YAGleNrTeaHTSYyiolgxB_g19sf2dkV6yeTiMNsekakMX0ZkS8lIvRBMxmlmc7Irj8VRMPhJrbzBdLAHAyTTViNOZ_xZt_fzFRGpkuTKKIjM2FiEcmdgh544egKIQpmS5QVsJ7DJS7gDTVNEd3ubVhIxc1Mt12pxxpvDYj99JMLmBZI3LBIcG2IKgt4BBMRpix494DN1B_DgzqUKhKQAQKMJYD6kEUkKWh64jUfeffZDU_H-MbcwrVDG2QdIcBSA9tTgQNLjVPFYroQnyEKABzw8adCAz0ozpqnf948rzurOU6jBKZKQTXVgkV5iLS8cgXpEZSzCXuRFGJsTzBOlIG-MzIysdqZKasR3sG-FF8K9me_Q7ephkMp53taPszM0yStkPCxfHBSAcFQT8QBmjFP6U2CcAoJFI6t8Nk0JBvT-hF0PLbZxlHbIM_AuezukFJTiv8ljjN0ooOK3QM6BS_FNL-VE2hTwO_tGjLhjCio9mu7-3jd291j1m9Lu7F_gQ2dBnjQAh4XipJwX_xxGOInVBIjdtpsKqZIpSG_Bf4SlXJmxBgL2TRLM5Mv8iqao3cM-KTAic4ANacxrIsIFLPzcRYlIxnAVg8xd7Rg7fEOEYEPHifhdFOWuQNEVschqSOFlgEvgtYjLedqAyIsi03SwEhYP3CHI08YQ6EK3HGiiAJulu4QX2Qf6QOkzSfgCg9SNvSWDXosHyzCx5wJraBeObZqBfdRxKcEPzO3oXne6Z98bbTPNt06DujdUbpMjSQvqCJaUKFSZaQbCiYJuxviQwDDxQmX1gpQPxGR10Rtn2PrrOvS_bxnWR3Ct6AV6Fsadgebx_LTOq551n5WpjhOEsQnBe56grToCwIeGZtDugKhLvTcnnvOF2a0OkuFyVKVx9mBjzHhgCL1BxZmrkrIgw9DKs6XOMFElMv9fFOsKLPy0m5G7ona6KV810LAl5WuTigVjC_S_jzlnrCnXGDxOlKfShGFP4Ryw5hUDjMj_hb11wSiR5oKKQ_bXMyOM1tDUkTMKKtCoBgeinrWFYZ5D7C_zU5s3O1mEQo4LQzrthrNq0H_fGCD0IqOgHj87CuZ5QVKoQRbGA-83LrcTqwLED-zuX0DnWPFLP36xpnbONg7FvZgA3uwwTE3wa1V_GdhLMOc36UWJ0h1sxiXQzuHOleht7CtotnHUgVlODWZtq30uWQxe7kcgopGIXCRAxkZ5ylwhShWzEfC10thcBYInfGaIoDOEzWD4PKzP-Hil7b3ys-9iIPH0ewVmFCycwzYFr9B4GOowA2HynicZMpoltxYlb15NQE6SS7DFh-7qo4Sd0x-Aa4cRWWazcooFsgHGhC8KbyM5c7ztnAeD522i5H2PAPXgJ-1er3G59ZSNyJ6Nq0HcoKik7kjcF20Zu589uPHq_NpAW14RhqY31qkGLe7nHEcyIrOvt2ssnan3-o2Tvrt886g3dy6vGw37w7RW_avLlpV1us3-pe9rU7rW5U1Tr5UWQevLWy76J6f4PitJpaeAE791qCJFzSZF83Zm4vG1dfzBpb_CsC10IZ3zy_77c7nwZfW1WPRzzMzTL6T1BfZEEEQrffAfVbMA2gMkLezeXwYokqsMvE9uOUKbxVa4NWDBxRbjrYfQzgpZgDLNV8nD2YNtNzzvsJ63oNshaLnhztsm0iscOllPDxYPc0l2FoyNCnTKWxbz_F5L80tu0gTkwRJhCpGhjOTLqWfd5mkRbbIwWm_IO4NRDOf5cT8QS5anSasnPvSwaIveTp_1Ze6AsU1wcSDA8dFD6ZXOdNTsHq8ww9jsGNhRNjyIMtt6iQpa-pUkO68AnJn14urHdk661HI2ViuiNmQxsHK7kaHHIxVco9GbhQLiLoFf_yFnPLNKonmMWYS8mP2i3XkxS1rylNPJbego7Z-fznYFDXmfL2_Ucq3uQMDsiKeJKiAzA6cMO_YGA1nbDqmOI6yBM2kHOdk0XTbGK-pCaMRjx15zJVD72YodCIsU_uAlLPsc6cuSP0InVQsWcIitBHS_00bbO-GKk3b4YTynRttKA1q8kFHbNtfaiCr7i_rkvl0Y0jN9JjiF3VlWI5-DS_42FVqNIMymcnseGWHnYg7PrG8fc2S03Z5z5Ur6Hc1Ck-_h063kTtLNh1l1MGm6Mr3ijOTXuWDbZGHKEJp7OWW27mFtUCY0cAy5VEoPjmKa0Dlw4pVxrbVRmEbG8co2rvovspUVMCtNddcLTUPvte-Algh44zZs-8AnlbZ6_FqP6ukW52hZmzn67cfrdnOf1O1nf-Rbmd8XQdofw63WSNDHEe4O-Mq4xEVI0LeiZAtWKbXa3_2Nz9sxdXP69-BPeb-ygZac8hXNE4btTOaaqbEfV4jfVrKYcn063nqSh-Nvnzq-GFI843ZOjvNOzGNOFMabN_wh4gXY1x8YOfdckrTf5qMxsgVpcZ4i4Ap8GWYobkXNP0X6k2ZLjV2NJKgubFgI8rw7pZAqGUU57YKutkQdpwsJ5R7JIstP7dTza1_AfBeMCNbp8IXcX3h2Oyv0l0_MvurVItx2TLCpYh1rd6j-HKlu49ULtp1W79dtnp9_P5H66S_PlJtrNhTPCdw5q6ySpN_En0k7aAssKMyN9fmhtvLPyAnoKJIx-JBi-c_PbBWmtiF5JIUob115P6KaAQPk-oTO85UplgySt1cKb_88SXrj8mgj9X9Q3Ln32bzgli2Gkf0czR7DCKPGvOee9mxBJ5CXv9WatjRfgpUMZUYGrtOCBYhmwpTumX8kk3TbGzo2oiuDxVZNIakIzmUdv6k6FbfFtFFF7AJKPgQRtdrts-hmp3qe1k89VJcBQKJOIm_cizYAVmuCUL_RBewM6jau-obqPcrn-J1KM2jiySvnsEJjyLm2037QU-kdzKYzVDnl_tv7Y5fOWzkOZWWz9LbLdf597PYU961irHvCfppVspNRFHqRhDQLLGcNFfJJ3m4eIzHGW_l5onh0bLdaull0AtOdcqLnT5krpThJY6BAnEF1JfMlJZzW93Mt0txftne5YOWpXOklUIuzpIclF8wS3I3mg-I9RR9U-__eUynHhpfo6V1Pay96M1nEJvCPUNUnh_UdrfZJaoLfY84Hfr5rZdi0IisPpbHELpQmTX85dsE-Kn37TuearTT7qqZdHQHLuSgrBHzvNv29dfje3dF9_a0zd5TgvsTkrrF9kJc0LQkm9Ldv732t4-nXHvbPkHlGaDMp6jL7OORmrpRahmV7COr7TKQZVvx7KEJBhcUE284sg-SKz1eoF3ZiFg55oF7WsDVq_Y5H3dr_-a5N9frj1xfmCE8Q0EAaJQk48EZlwggT2y4Qfg2lGwePQNU9ZdV5cfvCmjWtmmq1zn_9rXV_Nw6a3X6tnV8GpbnOfbHshgRWa4C6rMCwhXsKIuenaAncRxyShhZzXh5KLDfL6DDcuDFZFPQaNNPF9fst_RXs1-01ROCzttpzeLCRiuMsbf0YViEsZc_Cms3PedBWJfTfQf1f_YcrD_5f-Mp2ELJlWolRjTjMqzUK38Q8-uKuQWurit1_BnydHxduVZ_Yh3PTNKbqqBSN6gvqpU0yUa3lfoNpeVqxQUlb6vi0wlX_0ySON-CQGyS9Mw9C20fibZLKvU_Kt8r9bcHO7tv92tHtYOjo723e-8OqpVppb7_7v3O3uHe7kHt6LB2uF97_2e18mBp7u68f3_49uDo4PBdbe_oqLa__-d_AIdnu0U

1- SWIFT_CORE_TRAFFIC_STARTED

sequenceDiagram

    # SWIFT_CORE_TRAFFIC_STARTED = Swift Core sistemi mesaj trafigine basladiginda sistem bu tip ile bildirim iletecektir.

    SWCore_Message_Notification_Queue ->> Incoming_Swift_Notification_Listener: SWIFT_CORE_TRAFFIC_STARTED
    Incoming_Swift_Notification_Listener ->> swiftcore_interaction_table: insert SWIFT_CORE_TRAFFIC_STARTED



2- Message LISTENED

sequenceDiagram

    # interaction_request_table # Columns: id, interaction_id, type, status, source, payload, create_date, update_date
    # incoming_Swift_Messages_Table # (Columns id, index'li unique Message id(swiftcore'dan iletilecek MT=MIR, MX=Business Application Header'in MessageIdentifier yani her swift mesaji icin unique + Yardimci bu kolon primary key yerine unique constranint olsun dedi. Hem SWCore bagimliligi olmuyor hem de null olabiliyor.), inser_date, Queue_Name = Message_Type, status, UETR)

    SWCore_Pacs008_Pacs009_MT910_MT940_MT950_Queues ->> incoming_Swift_Message_Listener: New Message

    # Olasi Sorular, Feedback'ler ve Cozumleri
    ## Yeni Transaction icerisinde yapilmasi lazim -> MY Toplantisi
    ## Ayni Transaction icerisinde yapilmasi lazim -> MK Toplantisi -> Dogrusu bu !
    ## db'de ayni Transaction'da olup 1 table yerine 3'unu de rollback etmeli.
    ## isimlendirme onerisi: unique message id veya swcore_ref

    # Risks
	## !! SwiftCore at least one calistigi icin 2 kere ayni mesaji dinleme riski cozulmeli !!
	## 1 mesaj 3 farkli thread ile ayni milisaniyede islenmeye basladiginda ne olacak?
    ## Solution TODO: Ayni mesaj gonderilirse listener ayni unique msg id'si ile ekleme kontrolu yapacak.

    # Advantages
    ## MX versiyon bagimsiz.
    ## Dinledigimiz mesajlari claim karari oncesi neden kaydetmemiz gerekir.
    ### Mesaj claimde birbirini beklemesi gereken mesajlarin sahiplenebilmesi icin.
    #### MT103 MT202 MT940 mesajlarinin birbirini bekledigi caselerde.
    ### Karari o an vermek istemeyip daha sonra tekrar yurutmek istedigimizde.
    ### Belirli sure claim edilmeyen mesajlara logic yazmak istersek.    -> Body'i daha sonra da kaydedebilriz aslinda.
    ### Mesaj sahiplenme logic'ini gelistirmek icin kesin yararli olur. -> Tabi SWCore'dan da alinabilir.
    ### Bize baska esnekliklerde saglayacaktir.
    ### DONTCLAIM'lerde arsiv, partition, delete, ara tablo vb degerlendirilecek.

    incoming_Swift_Message_Listener ->> incoming_Swift_Messages_Table: Request ayni unique mesaj id'li kayit var mi?
    incoming_Swift_Messages_Table ->> incoming_Swift_Message_Listener: Boolean Response
    alt New Record?
        incoming_Swift_Message_Listener ->> SWCore_Pacs008_Pacs009_MT910_MT940_MT950_Queues: return message_listened_ack = duplicate listen or listened
    else
        incoming_Swift_Message_Listener ->> interaction_request_table: insert
        # incoming_Swift_Messages_Table
        incoming_Swift_Message_Listener ->> incoming_Swift_Messages_Table: insert status LISTENED
        incoming_Swift_Message_Listener ->> Swift_Messages_Sections_Table: insert
        incoming_Swift_Message_Listener ->> incoming_Swift_Messages_Fields_Table: insert
        incoming_Swift_Message_Listener ->> incoming_Swift_Messages_Attributes_Table: insert
        incoming_Swift_Message_Listener ->> SWCore_Pacs008_Pacs009_MT910_MT940_MT950_Queues: return message_listened_ack
    end
	
	# Buranin sonunda commit atiliyor.



3- Claim Rules set READY_TO_CLAIM

sequenceDiagram

	# + table isimlendirme onerisi: incoming_swift_messages

    # incoming_Swift_Messages_Table + swift_message_sections_table + swift_message_fields_table

    Claim_Rules_Batch ->> GetSwiftMessagesUseCase: Request LISTENED status and insert_date > SwiftCore tarafinda sahiplenilmeyen mesajlar icin olan alert time.
    GetSwiftMessagesUseCase ->> Claim_Rules_Batch: Response

    alt Claim Decision
        Claim_Rules_Batch ->> incoming_Swift_Messages_Table: Update status READY_TO_CLAIM
    else
        Claim_Rules_Batch ->> incoming_Swift_Messages_Table: Update status DONT_CLAIM (after certain amounts of time)
    else
        Claim_Rules_Batch ->> incoming_Swift_Messages_Table: No Update (aksiyon alinmiyor ama gorulmesi icin cizildi)
    end 



4- Claim Request Insert CLAIM_SWIFT_MESSAGE

sequenceDiagram
    participant Batch as Message_Claim_Batch
    participant Incoming as incoming_Swift_Messages_Table
    participant Interaction as interaction_response_table # ID, INTERACTION_ID(UUIDv7), TYPE, STATUS(NEW, ACK, NACKED, PROCESSED), CREATE_DATE, UPDATE_DATE, PAYLOAD, HEADER, ROUTING_KEY
    participant Outbox as Publisher_Outbox_Table # id, status, message_body, exchange_name, create_date, update_date, publish_date

    Batch ->> Incoming: Get All READY_TO_CLAIM Status Records
    Incoming -->> Batch: Response

    Batch ->> Incoming: Update Status CLAIM_SWIFT_MESSAGE, update_date
    Batch ->> Interaction: Insert with Protocol = id(UUIDv7), CLAIM_SWIFT_MESSAGE, message body 
    Batch ->> Outbox: Insert Outbox type CLAIM_SWIFT_MESSAGE, Status PENDING



5- Claim Request Outbox CLAIM_SWIFT_MESSAGE

sequenceDiagram
    participant Relay as Outbox_Process_Batch
    participant Outbox as Publisher_Outbox_Table
    participant SWCore as SWCore_Message_Exchange

    Relay ->> Outbox: Fetch PENDING Messages
    Relay ->> SWCore: Send # CLAIM_SWIFT_MESSAGE
    SWCore -->> Relay: Acknowledgment (ACK/NACK)
    Relay ->> Outbox: Update Status to ACK / NACK
    Relay ->> interaction_request_table: Update Request Status
    Relay ->> interaction_response_table: insert Response
    # SwiftCore exchange idempotent. Gelistirme planinda ama simdilik insert etmiyor seklinde calisiyor.



6- Claim Response CLAIM_SWIFT_MESSAGE_ACK CLAIM_SWIFT_MESSAGE_NACK

 sequenceDiagram
# + ClaimedACK, ClaimedNACK vb donus eklenecek.
# + SwiftCore a gonderim istekler, istek body'si ile birlikte, id'leri ayri bir table'da tutulacak. Cevap donulmeyen istekler icin alert olusturulacak.

# Outbox uygulayarak 2 sequencede ciz. -> burada outbox gerekmiyordur heralde?

# interaction_request_table: Insert Swift-Core Response with id, body, CLAIM_SWIFT_MESSAGE_ACK and CLAIM_SWIFT_MESSAGE_NACK

    alt Claim Response
        SWCore_Message_Notification_Queue ->> Incoming_Swift_Notification_Listener: CLAIM_SWIFT_MESSAGE_ACK
        Incoming_Swift_Notification_Listener ->> interaction_request_table: Insert CLAIM_SWIFT_MESSAGE_ACK
        Incoming_Swift_Notification_Listener ->> Incoming_Swift_Messages_Table: Update Status CLAIM_SWIFT_MESSAGE_ACK
    else
        SWCore_Message_Notification_Queue ->> Incoming_Swift_Notification_Listener: CLAIM_SWIFT_MESSAGE_NACK
        Incoming_Swift_Notification_Listener ->> interaction_request_table: Insert CLAIM_SWIFT_MESSAGE_NACK
        Incoming_Swift_Notification_Listener ->> Incoming_Swift_Messages_Table: Update Status CLAIM_SWIFT_MESSAGE_NACK
    end



7- Auto or Manual Received SWIFT_MESSAGE_ASSIGNED

 sequenceDiagram

    SWCore_Message_Notification_Queue ->> Incoming_Swift_Notification_Listener: SWIFT_MESSAGE_ASSIGNED
    Incoming_Swift_Notification_Listener ->> interaction_request_table: Insert SWIFT_MESSAGE_ASSIGNED

    Incoming_Swift_Notification_Listener ->> Incoming_Swift_Messages_Table: Is it a new message?
    Incoming_Swift_Messages_Table ->> Incoming_Swift_Notification_Listener: response
    alt Claimed
        Incoming_Swift_Notification_Listener ->> Incoming_Swift_Messages_Table: Update status SWIFT_MESSAGE_ASSIGNED
    else
        # Birden fazla claim eden nedeniyle alinamayan mesajlar (Manuele duseceginden)
        # Rule setimize girmediginden alinamayan mesajlar
        # Release edilip geri manuel alinanlar
        Incoming_Swift_Notification_Listener ->> incoming_Swift_Messages_Table: insert status SWIFT_MESSAGE_ASSIGNED
        Incoming_Swift_Notification_Listener ->> Swift_Messages_Sections_Table: insert
        Incoming_Swift_Notification_Listener ->> Swift_Messages_Fields_Table: insert
        Incoming_Swift_Notification_Listener ->> Swift_Messages_Attribute_Table: insert
    end




8- Cant Received CLAIM_REQUEST_REJECTED

 sequenceDiagram

    # CLAIM_REQUEST_REJECTED = Swift Mesaji sahiplenme istegi sonucunda mesaj atamasi gerceklesmezse sistem bu tip ile bildirim iletecektir.
    # CLAIM_REQUEST_REJECTED manual sahiplenme disinda neden gelsin? Bunun ogrenilmesi gerekiyor.
    SWCore_Message_Notification_Queue ->> Incoming_Swift_Notification_Listener: CLAIM_REQUEST_REJECTED
    Incoming_Swift_Notification_Listener ->> interaction_request_table: Insert CLAIM_REQUEST_REJECTED
    Incoming_Swift_Notification_Listener ->> incoming_Swift_Messages_Table: Update status CLAIM_REQUEST_REJECTED



9- Message Release SWIFT_MESSAGE_UNCLAIMED

 sequenceDiagram

    # This diagram is not completed yet.

    # Kuyruktan dinleniyormus gibi gorunuyor. -> SwiftCore'un manuel ekranindan is birimi mesaj sahiplenecekse neden kuyruktan gelmiyor demisler.
    # Transfer Layer bitirilecek.

    Release_Call ->> Release_Service: Request
    Release_Service ->> Has_Transfer: Request

    alt hasTransfer
        Has_Transfer ->> Release_Service: Response True
        alt isAccounted
            Release_Service ->> iade: Request
        else
            Release_Service ->> iptal: Request
        end
    else
        Has_Transfer ->> Release_Service: Response False
    end

    Release_Service ->> incoming_Swift_Messages_Table: Update status to SWIFT_MESSAGE_UNCLAIMED, update_date
    Release_Service ->> interaction_response_table: Insert
    Release_Service ->> Publisher_Outbox_Table: Insert Outbox type SWIFT_MESSAGE_UNCLAIMED, Status PENDING
    # 5- Claim Request Outbox CLAIM_SWIFT_MESSAGE ayni zamanda release bildirimlerini de outbox'dan exchange'e iletiyor.



10- Unanswered_Claim_Request_Alert

 sequenceDiagram

	# SwiftCore sahiplenilmemis mesaj varsa o da alert verecek. Ama burada claim etmek istedigimizden o alertten once Unanswered_Claim_Request_Alert alerti gelende uyari vermeli.
	
    Unanswered_Claim_Request_Alert ->> incoming_Swift_Messages_Table: Get All CLAIM_SWIFT_MESSAGE status records update_date > 10 min (mesaj claim taleplerini iletme suresinden birkac daha fazla yapilabilir)
    incoming_Swift_Messages_Table ->> Unanswered_Claim_Request_Alert: Response
    Unanswered_Claim_Request_Alert ->> Outlook_Mail: Unanswered_Claim_Request_Alert for this unique message id, and interaction_id



11- ACKNOWLEDGEMENT_NACK_Alert

 sequenceDiagram

	# Outbox'daki isteklere mesela Claim'e NACK gelirse alerti.
	
    ACKNOWLEDGEMENT_NACK_Alert ->> Publisher_Outbox_NACK_Table: Get All NACK acknowledgements
    Publisher_Outbox_NACK_Table ->> ACKNOWLEDGEMENT_NACK_Alert: Response
    ACKNOWLEDGEMENT_NACK_Alert ->> Outlook_Mail: ACKNOWLEDGEMENT_NACK_Alert for this interaction_id



12- SWIFT_CORE_TRAFFIC_ENDED

sequenceDiagram

    # SWIFT_CORE_TRAFFIC_ENDED = Swift Core sistemi mesaj trafigin bitirdiginde sistem bu tip ile bildirim iletecektir.

    SWCore_Message_Notification_Queue ->> Incoming_Swift_Notification_Listener: SWIFT_CORE_TRAFFIC_ENDED
    Incoming_Swift_Notification_Listener ->> swiftcore_interaction_table: insert SWIFT_CORE_TRAFFIC_ENDED

